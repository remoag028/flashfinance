<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlashFinance Real-Time News (Netlify Secure)</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Set up configuration for Tailwind -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'flash-purple': '#4c1d95',
                        'flash-blue': '#4f46e5',
                        'flash-green': '#10b981',
                        'flash-red': '#ef4444',
                        'flash-yellow': '#f59e0b',
                        'bg-gray': '#f8fafc',
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
        }
        .flash-card {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .article-content {
            white-space: pre-wrap;
            line-height: 1.6;
            margin-top: 1rem;
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="max-w-4xl mx-auto">
        <header class="mb-8 text-center">
            <h1 class="text-4xl font-extrabold text-gray-900">
                <span class="text-flash-purple">Flash</span>Finance
            </h1>
            <p class="text-gray-500 mt-2">
                Real-time, secure financial news powered by Google Gemini and Netlify Functions.
            </p>
        </header>

        <!-- Main News Feed -->
        <div id="news-feed" class="space-y-6">
            <!-- News Cards will be injected here -->
        </div>

        <!-- Dynamic Message Box (for errors/info) -->
        <div id="message-box" class="mt-6 hidden"></div>

        <!-- Global Loader for News Fetching -->
        <div id="news-loader" class="text-center py-8 hidden">
            <svg class="animate-spin h-8 w-8 text-flash-purple mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="text-gray-500 mt-2">Fetching the latest finance headlines...</p>
        </div>

        <!-- Footer -->
        <footer class="mt-12 text-center text-gray-400 text-sm">
            <p>Content generation powered by Gemini AI.</p>
        </footer>
    </div>

    <script>
        // FIX 1: Removed leading slash to prevent URL parsing errors in some execution environments.
        const NEWS_PROXY_ENDPOINT = '.netlify/functions/get-news';
        const MAX_ARTICLES = 15;

        let liveNewsData = []; // Stores all fetched articles
        let isFetching = false;
        let articlesRendered = 0;

        /**
         * Renders a single news card element.
         */
        function renderNewsCard(article) {
            const card = document.createElement('div');
            card.className = 'flash-card bg-white p-5 rounded-xl border border-gray-100';
            card.innerHTML = `
                <h2 class="text-xl font-bold text-gray-900 mb-2">${article.title}</h2>
                <div class="flex justify-between items-center text-xs text-gray-500 mb-4 border-b pb-2">
                    <span>Source: ${article.source}</span>
                    <span>Published: ${article.date}</span> <!-- UPDATED: Display the formatted date -->
                </div>
                
                <div id="content-${article.id}" class="article-content text-gray-700">
                    <!-- Placeholder/Initial Content -->
                    <p>${article.originalText.substring(0, 150)}...</p>
                </div>

                <div class="flex justify-between items-center mt-4">
                    <button 
                        id="btn-toggle-${article.id}" 
                        class="summarize-btn px-4 py-2 bg-flash-purple text-white text-sm font-semibold rounded-lg hover:bg-opacity-90 transition duration-150 flex items-center" 
                        data-id="${article.id}"
                        data-state="original"
                    >
                        <svg id="loader-${article.id}" class="animate-spin h-4 w-4 mr-2 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                        </svg>
                        <span id="text-toggle-${article.id}">Generate Flash Summary</span>
                    </button>
                    <!-- Link now uses the specific link derived from grounding metadata -->
                    <a href="${article.link}" target="_blank" rel="noopener noreferrer" class="text-flash-blue hover:underline text-sm font-medium">Read Full Article</a>
                </div>
            `;
            document.getElementById('news-feed').appendChild(card);
            
            // Attach event listener for the summary button
            card.querySelector(`#btn-toggle-${article.id}`).addEventListener('click', () => toggleSummary(article.id));
        }

        /**
         * Displays a temporary message (error or info)
         */
        function displayMessage(message, type = 'info') {
            const box = document.getElementById('message-box');
            
            // FIX 2: Correctly remove all conflicting classes and add classes individually
            box.classList.remove('hidden', 'bg-red-100', 'border-red-400', 'text-red-700', 'bg-blue-100', 'border-blue-400', 'text-blue-700', 'border', 'px-4', 'py-3', 'rounded-xl', 'mb-6', 'shadow-md'); 

            // Add type-specific classes
            if (type === 'error') {
                box.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
            } else {
                box.classList.add('bg-blue-100', 'border-blue-400', 'text-blue-700');
            }

            // Add common classes
            box.classList.add('border', 'px-4', 'py-3', 'rounded-xl', 'mb-6', 'shadow-md');
            box.classList.remove('hidden');

            box.innerHTML = `<p>${message}</p>`;
            
            // Hide after 5 seconds
            setTimeout(() => {
                box.classList.add('hidden');
            }, 5000);
        }

        /**
         * Helper function to call the Netlify proxy securely with exponential backoff.
         * The function is generic and accepts a payload and endpoint.
         */
        async function callProxyApi(endpoint, payload, isJson = true, maxAttempts = 5) {
            let attempts = 0;
            while (attempts < maxAttempts) {
                try {
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429) {
                        const delay = Math.pow(2, attempts) * 1000 + Math.random() * 1000;
                        attempts++;
                        if (attempts >= maxAttempts) throw new Error("API Rate Limit Exceeded");
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; // Retry
                    }

                    if (!response.ok) {
                        const errorBody = await response.json().catch(() => response.text());
                        throw new Error(`Proxy Error: ${response.status} - ${JSON.stringify(errorBody)}`);
                    }

                    const result = await response.json();
                    
                    // Client-side processing of the raw Gemini response
                    const candidate = result.candidates?.[0];
                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const text = candidate.content.parts[0].text;
                        
                        let sources = [];
                        const groundingMetadata = candidate.groundingMetadata;
                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            sources = groundingMetadata.groundingAttributions
                                .map(attribution => ({
                                    uri: attribution.web?.uri,
                                    title: attribution.web?.title,
                                    date: attribution.web?.publish_date, // ADDED: Extract publish date
                                }))
                                .filter(source => source.uri && source.title);
                        }
                        
                        return { text, sources };
                    } else {
                        throw new Error("API response content was empty or malformed.");
                    }

                } catch (error) {
                    if (attempts < maxAttempts - 1) {
                        attempts++;
                        const delay = Math.pow(2, attempts) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw error;
                    }
                }
            }
        }

        /**
         * Fetches news using the Netlify function proxy.
         */
        async function fetchNews() {
            // Check if we already fetched enough articles or are currently fetching
            if (isFetching || liveNewsData.length >= MAX_ARTICLES) return; 
            isFetching = true;

            const loader = document.getElementById('news-loader');
            if (loader) loader.classList.remove('hidden');

            // CRITICAL FIX: Ensure 'type: "fetch"' is included in the payload
            const payload = {
                type: 'fetch', // Tells get-news.js to run the news fetching logic
                // No additional parameters needed for the first page
            };

            try {
                // The proxy returns { text: markdown_string, sources: [] }
                const result = await callProxyApi(NEWS_PROXY_ENDPOINT, payload, true); 

                if (result && result.text) {
                    // Use a simple markdown parser to extract articles
                    const articles = parseMarkdownArticles(result.text, result.sources);

                    // Append new articles to the global store
                    liveNewsData.push(...articles);
                    
                    // Render only the new articles
                    renderNewArticles();
                } else {
                    displayMessage('Proxy returned an empty or invalid result.', 'error');
                }
                
            } catch (error) {
                console.error('Failed to fetch news:', error);
                displayMessage(`Failed to load news: ${error.message || 'Unknown error'}`, 'error');
            } finally {
                isFetching = false;
                if (loader) loader.classList.add('hidden');
            }
        }

        /**
         * Renders articles that haven't been rendered yet.
         */
        function renderNewArticles() {
            const articlesToRender = liveNewsData.slice(articlesRendered);
            articlesToRender.forEach(renderNewsCard);
            articlesRendered = liveNewsData.length;
        }

        /**
         * Parses the markdown string from the Gemini response into structured article objects.
         */
        function parseMarkdownArticles(markdownText, sources) {
            const articles = [];
            // Regex to find H2 titles (##) and the following paragraph text
            const articleRegex = /##\s*(.*?)\s*\n\s*((?:(?!\n##|\n\n-|\n\n\[).)*)/gs;
            let match;
            let currentId = liveNewsData.length + 1;

            while ((match = articleRegex.exec(markdownText)) !== null) {
                const title = match[1].trim();
                let fullText = match[2].trim();

                // Clean up any remaining leading/trailing whitespace or empty lines
                fullText = fullText.replace(/[\r\n]{2,}/g, '\n\n').trim();

                if (title && fullText) {
                    // UPDATED LOGIC: Cycle through the available sources to assign unique links/titles/dates
                    const sourceIndex = sources.length > 0 ? articles.length % sources.length : 0;
                    const sourceData = sources.length > 0 ? sources[sourceIndex] : { title: 'Gemini Search', uri: '#', date: null };

                    // Format the date if available
                    const formattedDate = sourceData.date 
                        ? new Date(sourceData.date).toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }) 
                        : 'Date Unavailable';

                    articles.push({
                        id: currentId++,
                        title: title,
                        originalText: fullText,
                        source: sourceData.title, // Use the actual source title
                        link: sourceData.uri,      // Use the actual source URI
                        date: formattedDate,       // Include the formatted date
                        summary: null, // Will be populated by the summary click
                    });
                }
            }
            return articles;
        }

        /**
         * Generates and displays the summary when the button is clicked.
         */
        async function toggleSummary(articleId) {
            const article = liveNewsData.find(a => a.id === articleId);
            const contentArea = document.getElementById(`content-${articleId}`);
            const button = document.getElementById(`btn-toggle-${articleId}`);
            const textSpan = document.getElementById(`text-toggle-${articleId}`);
            const loader = document.getElementById(`loader-${articleId}`);

            if (!article || !contentArea || !button) return;

            const currentState = button.getAttribute('data-state');

            if (currentState === 'summary' && article.summary) {
                // Action: Hide Summary, show Original Text
                contentArea.innerHTML = `<p>${article.originalText.substring(0, 150)}...</p>`;
                textSpan.textContent = 'Generate Flash Summary';
                button.setAttribute('data-state', 'original');
                button.classList.remove('bg-flash-red');
                button.classList.add('bg-flash-purple');
                return;
            }

            if (article.summary) {
                // Action: Show Summary (already generated)
                contentArea.innerHTML = `<div class="font-bold mb-1 text-flash-purple">Flash Summary (60 Words Max):</div><p class="font-medium">${article.summary}</p>`;
                textSpan.textContent = 'Hide Summary';
                button.setAttribute('data-state', 'summary');
                button.classList.remove('bg-flash-purple');
                button.classList.add('bg-flash-red');
                return;
            }
            
            // --- Action: Generate Summary (First Time) ---
            button.disabled = true;
            loader.classList.remove('hidden');
            textSpan.textContent = 'Generating...';

            const summaryPayload = {
                type: 'summarize', // Tells get-news.js to run the summary logic
                textToSummarize: article.originalText,
            };

            try {
                // Call the proxy for summarization
                const result = await callProxyApi(NEWS_PROXY_ENDPOINT, summaryPayload, false); // False because we want a concise text response

                if (result && result.text) {
                    // Update the article data and UI
                    article.summary = result.text.trim(); // Save the summary
                    contentArea.innerHTML = `<div class="font-bold mb-1 text-flash-purple">Flash Summary (60 Words Max):</div><p class="font-medium">${article.summary}</p>`;
                    textSpan.textContent = 'Hide Summary';
                    button.setAttribute('data-state', 'summary');
                    button.classList.remove('bg-flash-purple');
                    button.classList.add('bg-flash-red');

                } else {
                    displayMessage('Failed to generate summary. The AI response was empty.', 'error');
                    textSpan.textContent = 'Retry Summary';
                }
            } catch (e) {
                console.error("Summarization failed:", e);
                displayMessage(`Summarization failed: ${e.message}`, 'error');
                textSpan.textContent = 'Retry Summary';
            } finally {
                button.disabled = false;
                loader.classList.add('hidden');
            }
        }

        /**
         * Handles scrolling to trigger infinite load.
         */
        function handleScroll() {
            const scrollPosition = window.innerHeight + window.scrollY;
            const documentHeight = document.body.offsetHeight;
            
            // Trigger fetch when user is near the bottom
            if (scrollPosition >= documentHeight - 500 && !isFetching && liveNewsData.length < MAX_ARTICLES) {
                fetchNews();
            }
        }

        // --- Initialization and Event Listeners ---
        window.addEventListener('scroll', handleScroll);
        
        window.onload = function() {
            fetchNews(); // Initial load
        }

    </script>
</body>
</html>